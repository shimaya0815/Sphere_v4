import React, { useState, useEffect, useRef, useCallback, forwardRef } from 'react';
import { HiOutlinePaperAirplane, HiOutlineTrash, HiOutlineAtSymbol, HiOutlinePaperClip, HiOutlineBold, HiDocumentText } from 'react-icons/hi';
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';
import toast from 'react-hot-toast';
import { tasksApi, usersApi, chatApi } from '../../api';
import useWebSocket from '../../hooks/useWebSocket';

// é–‹ç™ºç’°å¢ƒã§ã®ãƒ‡ãƒãƒƒã‚°ãƒ•ãƒ©ã‚°
const DEBUG_QUILL = true;

// ReactQuillã®findDOMNodeéæ¨å¥¨è­¦å‘Šã‚’æŠ‘åˆ¶ã™ã‚‹ãŸã‚ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
const QuillWrapper = React.forwardRef(({ value, onChange, placeholder, modules, formats, disabled }, ref) => {
  return (
    <ReactQuill
      ref={ref}
      value={value}
      onChange={onChange}
      modules={modules}
      formats={formats}
      placeholder={placeholder}
      theme="snow"
      className="quill-editor"
      readOnly={disabled}
    />
  );
});

QuillWrapper.displayName = 'QuillWrapper';

// Quillã‚¨ãƒ‡ã‚£ã‚¿ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
const quillStyles = `
.quill-editor {
  margin-bottom: 0;
  height: 150px;
}

.quill-container {
  width: 100%;
  border: 1px solid #e5e7eb;
  border-radius: 0.375rem;
  overflow: hidden;
}

.quill-container .quill {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.quill-editor .ql-container {
  border-radius: 0 0 4px 4px;
  min-height: 100px;
  font-size: 0.875rem;
  border-top: 0 !important;
  height: calc(100% - 42px);
}

.quill-editor .ql-toolbar {
  border-radius: 4px 4px 0 0;
  border-bottom: 1px solid #e5e7eb;
  background-color: #f9fafb;
}

/* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è¡¨ç¤ºç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.quill-content {
  font-size: 0.875rem;
  line-height: 1.5;
}

.quill-content img {
  max-width: 100%;
  height: auto;
  margin: 8px 0;
  border-radius: 4px;
}

.quill-content p {
  margin-bottom: 0.5rem;
}

.quill-content blockquote {
  border-left: 3px solid #ccc;
  padding-left: 0.75rem;
  margin-left: 0;
  color: #666;
}

.quill-content pre {
  background-color: #f1f1f1;
  border-radius: 3px;
  padding: 0.5rem;
  font-family: monospace;
  white-space: pre-wrap;
}

.quill-content .ql-syntax {
  background-color: #f8f8f8;
  border-radius: 3px;
  padding: 0.5rem;
  font-family: monospace;
  white-space: pre-wrap;
}

.quill-content ul, .quill-content ol {
  padding-left: 1.5rem;
  margin-bottom: 0.5rem;
}

.quill-content ul li {
  list-style-type: disc;
}

.quill-content ol li {
  list-style-type: decimal;
}

.quill-content a {
  color: #2563eb;
  text-decoration: underline;
}

.quill-content strong, .quill-content b {
  font-weight: bold;
}

.quill-content em, .quill-content i {
  font-style: italic;
}
`;

const TaskComments = ({ taskId, task, onCommentAdded }) => {
  const [comments, setComments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [newComment, setNewComment] = useState('');
  const [editorContent, setEditorContent] = useState('');
  const [editorHtml, setEditorHtml] = useState('');
  const [submitting, setSubmitting] = useState(false);
  const [users, setUsers] = useState([]);
  const [mentionSuggestions, setMentionSuggestions] = useState([]);
  const [showMentionSuggestions, setShowMentionSuggestions] = useState(false);
  const [mentionQueryStart, setMentionQueryStart] = useState(-1);
  const [mentionQuery, setMentionQuery] = useState('');
  const [pastedImages, setPastedImages] = useState([]);
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [mentionedUsers, setMentionedUsers] = useState([]);
  
  const commentInputRef = useRef(null);
  const quillRef = useRef(null);
  const mentionSuggestionsRef = useRef(null);
  const fileInputRef = useRef(null);
  
  // ReactQuillãŒæ­£ã—ãèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
  useEffect(() => {
    try {
      // ReactQuillã®ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ã‚’ç¢ºèª
      if (typeof ReactQuill === 'function') {
        if (DEBUG_QUILL) console.log('ReactQuill loaded successfully');
      } else {
        console.error('ReactQuill is not a function:', typeof ReactQuill);
      }
    } catch (error) {
      console.error('Error checking ReactQuill:', error);
    }
  }, []);
  
  // Quillã‚¨ãƒ‡ã‚£ã‚¿ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š
  const modules = {
    toolbar: [
      ['bold', 'italic', 'underline', 'strike'],
      ['blockquote', 'code-block'],
      [{ 'list': 'ordered' }, { 'list': 'bullet' }],
      ['link', 'image'],
      ['clean']
    ],
    clipboard: {
      matchVisual: false,
    },
    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ï¼ˆãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ç”¨ï¼‰
    keyboard: {
      bindings: {
        // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å€™è£œãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹æ™‚ã®ã‚­ãƒ¼æ“ä½œ
        mention_select: {
          key: 13, // Enterã‚­ãƒ¼
          handler: function() {
            if (showMentionSuggestions && mentionSuggestions.length > 0) {
              handleSelectMention(mentionSuggestions[0]);
              return false;
            }
            return true;
          }
        },
        mention_escape: {
          key: 27, // Escapeã‚­ãƒ¼
          handler: function() {
            if (showMentionSuggestions) {
              setShowMentionSuggestions(false);
              return false;
            }
            return true;
          }
        }
      }
    }
  };
  
  // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæŒ‡å®š
  const formats = [
    'bold', 'italic', 'underline', 'strike',
    'blockquote', 'code-block',
    'list', 'bullet',
    'link', 'image'
  ];
  
  // WebSocketã®æ¥ç¶šã¨è¨­å®š - ã‚¿ã‚¹ã‚¯å°‚ç”¨WebSocketã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½¿ç”¨
  // ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’è‡ªå‹•åˆ¤å®šï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ãŒhttpsãªã‚‰ã€wssã‚’ä½¿ã†ï¼‰
  const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
  
  // WebSocketã®URLã‚’æ§‹ç¯‰
  let wsUrl = null;
  if (taskId) {
    // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªãƒ›ã‚¹ãƒˆåã‚’ä½¿ç”¨ - ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§ã‚¢ã‚¯ã‚»ã‚¹
    let wsHost = window.location.host; // ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ›ã‚¹ãƒˆåã‚’ä½¿ç”¨(localhost:3000ãªã©)
    
    // ProxyãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®URLè¨­å®šã«åˆã‚ã›ãŸãƒ‘ã‚¹æ§‹ç¯‰
    wsUrl = `${wsProtocol}://${wsHost}/tasks/${taskId}/`;
    
    console.log(`Environment: ${process.env.NODE_ENV}, Protocol: ${wsProtocol}, Host: ${wsHost}`);
  }
  console.log(`WebSocket URL for task ${taskId}: ${wsUrl}`);
  
  const [connectionAttempts, setConnectionAttempts] = useState(0);
  const [connectionError, setConnectionError] = useState(false);
  
  // ãƒ¢ãƒƒã‚¯å›é¿ï¼šWebSocketæ¥ç¶šã‚’ç„¡åŠ¹åŒ–ã—ã¦å˜ç´”ãªHTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã¿ã§ãƒšãƒ¼ã‚¸ãŒå‹•ä½œã™ã‚‹ã‚ˆã†ä¿®æ­£
  // ä¸€æ™‚çš„ã«WebSocketã‚’ç„¡åŠ¹åŒ–
  const wsEnabled = false;
  
  // è­¦å‘Šã‚’è¡¨ç¤ºã—ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ã‚’ç„¡åŠ¹åŒ–
  const useSimpleTextArea = false;
  
  const { sendMessage, isConnected, connect } = useWebSocket(
    wsEnabled ? wsUrl : null, 
    {
      onOpen: () => {
        console.log(`Connected to task WebSocket for task ID: ${taskId}`);
        setConnectionError(false);
        setConnectionAttempts(0);
        toast.success('ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥ã«æ¥ç¶šã—ã¾ã—ãŸ', { id: 'ws-connected', duration: 2000 });
        
        // åˆå›Pingã¯å³æ™‚é€ä¿¡
        setTimeout(() => {
          if (isConnected) {
            sendMessage(JSON.stringify({
              type: 'ping',
              data: { timestamp: new Date().toISOString() }
            }));
            console.log('Sent initial ping to server');
          }
        }, 500);
        
        // å®šæœŸçš„ãªPingã‚’é€ä¿¡ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’è¨­å®š
        const pingInterval = setInterval(() => {
          if (isConnected) {
            sendMessage(JSON.stringify({
              type: 'ping',
              data: { timestamp: new Date().toISOString() }
            }));
            console.log('Sent ping to server');
          } else {
            clearInterval(pingInterval);
          }
        }, 30000); // 30ç§’ã”ã¨ã«Ping
        
        // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—æ™‚ã«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
        return () => clearInterval(pingInterval);
      },
      onMessage: (event) => {
        try {
          // ãƒ‡ãƒ¼ã‚¿ã®æ­£è¦åŒ–ï¼ˆæ–‡å­—åˆ—ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸¡æ–¹ã«å¯¾å¿œï¼‰
          const data = typeof event === 'string' ? JSON.parse(event) : event;
          
          console.log("Received WebSocket message:", data);
          
          // æ¥ç¶šç¢ºç«‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ä¿¡ã—ãŸå ´åˆã¯æ¥ç¶šã‚¨ãƒ©ãƒ¼ã‚’ã‚¯ãƒªã‚¢
          if (data.type === 'connection_established') {
            console.log('Connection established with server for task', taskId);
            setConnectionError(false);
            setConnectionAttempts(0);
          }
          // ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã¯ã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ã‚’å†å–å¾—
          else if (data.type === 'comment_added') {
            console.log('Comment added notification received');
            fetchComments();
          }
          // Pingã¸ã®å¿œç­”
          else if (data.type === 'pong') {
            console.log('Received pong from server:', data);
            // æ¥ç¶šãŒç”Ÿãã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢ï¼‰
            if (connectionError) {
              setConnectionError(false);
            }
          }
        } catch (error) {
          console.error("Error handling WebSocket message:", error);
        }
      },
      onClose: () => {
        console.log('Disconnected from task WebSocket');
        // è‡ªå‹•çš„ã«å†æ¥ç¶šã‚’è©¦ã¿ã‚‹
        const newAttempts = connectionAttempts + 1;
        setConnectionAttempts(newAttempts);
        
        if (newAttempts >= 5) {
          setConnectionError(true);
          // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯é–‹ç™ºä¸­ãªã®ã§éè¡¨ç¤º
          // toast.error('é€šçŸ¥ã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ', { id: 'ws-error', duration: 3000 });
        }
      },
      onError: (error) => {
        console.error('Task WebSocket error:', error);
        setConnectionError(true);
        
        // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯é–‹ç™ºä¸­ãªã®ã§éè¡¨ç¤º
        // if (connectionAttempts >= 2) {
        //   toast.error('é€šçŸ¥ã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ', { id: 'ws-error', duration: 3000 });
        // }
      },
      // è‡ªå‹•å†æ¥ç¶šè¨­å®š
      reconnectInterval: 3000,
      reconnectAttempts: 10,
      automaticOpen: true, // è‡ªå‹•æ¥ç¶šã‚’æœ‰åŠ¹ã«
    }
  );
  
  // æ˜ç¤ºçš„ãªå†æ¥ç¶šæ©Ÿèƒ½
  const handleReconnect = () => {
    // æ¥ç¶šçŠ¶æ…‹ã«é–¢ã‚ã‚‰ãšå¼·åˆ¶çš„ã«å†æ¥ç¶šã‚’è©¦ã¿ã‚‹
    console.log('Reconnect button clicked. Current connection state:', isConnected ? 'Connected' : 'Disconnected');
    
    // ç¾åœ¨ã®WebSocketã‚’æ˜ç¤ºçš„ã«é–‰ã˜ã¦ã€æ–°ã—ã„æ¥ç¶šã‚’ä½œæˆ
    if (wsUrl) {
      connect();  // useWebSocket hookã®connecté–¢æ•°ã‚’å‘¼ã³å‡ºã—
      console.log('Manual reconnection initiated');
      
      // é–‹ç™ºä¸­ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®é€šçŸ¥ã‚’ç„¡åŠ¹åŒ–
      // toast('é€šçŸ¥ã‚µãƒ¼ãƒãƒ¼ã«å†æ¥ç¶šã—ã¦ã„ã¾ã™...', { id: 'ws-reconnect' });
      
      setConnectionAttempts(0);
      setConnectionError(false);
    } else {
      console.warn('Cannot reconnect: WebSocket URL not set');
      // toast.error('æ¥ç¶šå…ˆãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“', { id: 'ws-error-no-url' });
    }
  };

  // å…±é€šã®ã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ç¢ºèªãƒ»ä½œæˆã™ã‚‹
  useEffect(() => {
    const checkTaskChannel = async () => {
      if (!taskId || !task) return;
      
      try {
        console.log('Checking for common task channel');
        
        // å…±é€šã®taskãƒãƒ£ãƒ³ãƒãƒ«ã‚’æ¢ã™
        const myChannels = await chatApi.getMyChannels();
        let taskChannel = null;
        
        // æ—¢å­˜ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‹ã‚‰ã€Œtaskã€ã‚’æ¤œç´¢ï¼ˆå¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã›ãšï¼‰
        if (Array.isArray(myChannels)) {
          for (const workspace of myChannels) {
            if (workspace && Array.isArray(workspace.channels)) {
              const foundChannel = workspace.channels.find(
                c => c && c.name && c.name.toLowerCase() === 'task'
              );
              
              if (foundChannel) {
                taskChannel = foundChannel;
                console.log('Found existing task channel:', taskChannel);
                break;
              }
            }
          }
        } else {
          console.log('Channels data structure is not as expected:', myChannels);
        }
        
        if (!taskChannel) {
          console.log('No task channel found, creating a common one');
          // ã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«ãŒãªã‘ã‚Œã°ä½œæˆ
          const workspace = await chatApi.getDefaultWorkspace();
          
          if (workspace) {
            try {
              taskChannel = await chatApi.createChannel({
                name: 'task',
                description: 'ã‚¿ã‚¹ã‚¯é–¢é€£ã®é€šçŸ¥ã‚„è­°è«–ã®ãŸã‚ã®å…±é€šãƒãƒ£ãƒ³ãƒãƒ«ã§ã™',
                workspace: workspace.id,
                channel_type: 'public'
              });
              
              console.log('Common task channel created:', taskChannel);
              toast.success('ã‚¿ã‚¹ã‚¯ç”¨ãƒãƒ£ãƒ³ãƒãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ');
            } catch (createError) {
              console.error('Error creating task channel:', createError);
              // ã‚¨ãƒ©ãƒ¼ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¨˜éŒ²ã™ã‚‹ã ã‘ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯è¡¨ç¤ºã—ãªã„
            }
          } else {
            console.error('No default workspace found for task channel creation');
          }
        }
      } catch (error) {
        console.error('Error checking task channel:', error);
      }
    };
    
    // ã‚¿ã‚¹ã‚¯IDã¨ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã€ãƒãƒ£ãƒ³ãƒãƒ«ç¢ºèªã‚’å®Ÿè¡Œ
    if (taskId && task) {
      checkTaskChannel();
    }
  }, [taskId, task]);

  // ãƒ“ã‚¸ãƒã‚¹å†…ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã‚’å–å¾—
  useEffect(() => {
    const fetchUsers = async () => {
      try {
        console.log('Fetching users for mention suggestions');
        const currentUser = await usersApi.getCurrentUser();
        if (currentUser && currentUser.business) {
          const businessUsers = await usersApi.getBusinessUsers(currentUser.business);
          const usersList = Array.isArray(businessUsers) ? businessUsers : businessUsers.results || [];
          console.log(`Fetched ${usersList.length} users for mentions`);
          setUsers(usersList);
        }
      } catch (error) {
        console.error('Error fetching users for mentions:', error);
      }
    };
    
    fetchUsers();
  }, []);

  // ã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ã‚’å–å¾—
  const fetchComments = async () => {
    if (!taskId) return;
    
    setLoading(true);
    try {
      console.log(`Fetching comments for task ID: ${taskId}`);
      const data = await tasksApi.getComments(taskId);
      const commentsList = data.results || data;
      console.log(`Received ${commentsList.length} comments for task ${taskId}`);
      
      // ãƒ‡ãƒ¼ã‚¿ã®å‰å‡¦ç†ã¨æ¤œè¨¼
      const processedComments = commentsList.map(comment => {
        // ã‚³ãƒ¡ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ã‚°ã«å‡ºåŠ›ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
        console.log(`Comment ${comment.id}:`, {
          content: comment.content?.substring(0, 30) + (comment.content?.length > 30 ? '...' : ''),
          has_html: !!comment.html_content,
          html_length: comment.html_content?.length || 0
        });
        
        // HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®æ¤œè¨¼
        if (comment.html_content) {
          // ç©ºã®HTMLã‚’ãƒã‚§ãƒƒã‚¯
          if (comment.html_content === '<p><br></p>' || comment.html_content === '<p></p>') {
            console.log(`Comment ${comment.id}: Empty HTML detected, using content instead`);
            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‹ã‚‰HTMLã‚’ç”Ÿæˆ
            return {
              ...comment,
              html_content: comment.content ? `<p>${comment.content.replace(/\n/g, '</p><p>')}</p>` : null
            };
          }
        } else if (comment.content) {
          // HTMLãŒãªãã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚ã‚‹å ´åˆã¯å¤‰æ›
          console.log(`Comment ${comment.id}: No HTML, generating from content`);
          return {
            ...comment,
            html_content: `<p>${comment.content.replace(/\n/g, '</p><p>')}</p>`
          };
        }
        
        return comment;
      });
      
      setComments(processedComments);
      setError(null);
    } catch (error) {
      console.error(`Error fetching comments for task ${taskId}:`, error);
      setError('ã‚³ãƒ¡ãƒ³ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚');
      toast.error('ã‚³ãƒ¡ãƒ³ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      setLoading(false);
    }
  };
  
  // ã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ã‚’å–å¾—ï¼ˆuseEffectç”¨ï¼‰
  useEffect(() => {
    if (taskId) {
      fetchComments();
    } else {
      console.log('No taskId provided, skipping comment fetch');
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [taskId]);

  // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å€™è£œã‚’å‡¦ç†
  useEffect(() => {
    if (mentionQuery && mentionQuery.length > 0) {
      const filteredUsers = users.filter(user => {
        const fullName = user.get_full_name || user.email || '';
        return fullName.toLowerCase().includes(mentionQuery.toLowerCase());
      }).slice(0, 5); // æœ€å¤§5äººã¾ã§è¡¨ç¤º
      
      setMentionSuggestions(filteredUsers);
      setShowMentionSuggestions(filteredUsers.length > 0);
    } else {
      setShowMentionSuggestions(false);
    }
  }, [mentionQuery, users]);

  // ä¾å­˜é–¢ä¿‚ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£ã™ã‚‹ãŸã‚ã€handlePasteã‚’useCallbackã§ãƒ¡ãƒ¢åŒ–
  const handlePaste = useCallback((e) => {
    const clipboardData = e.clipboardData;
    const items = clipboardData.items;
    let hasImage = false;
    
    for (let i = 0; i < items.length; i++) {
      if (items[i].type.indexOf('image') !== -1) {
        hasImage = true;
        
        const blob = items[i].getAsFile();
        const imageUrl = URL.createObjectURL(blob);
        
        // ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¿½åŠ 
        setPastedImages(prev => [...prev, {
          id: Date.now().toString(),
          file: blob,
          url: imageUrl
        }]);
      }
    }
    
    // ç”»åƒãŒãƒšãƒ¼ã‚¹ãƒˆã•ã‚ŒãŸå ´åˆã®ã¿ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    if (hasImage) {
      e.preventDefault();
      toast.success('ç”»åƒãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸ');
    }
    
    // ãƒ†ã‚­ã‚¹ãƒˆã®ãƒšãƒ¼ã‚¹ãƒˆã¯ãã®ã¾ã¾é€šå¸¸é€šã‚Šå‡¦ç†
  }, []);
  
  // ç”»åƒã®å‰Šé™¤
  const handleRemoveImage = (imageId) => {
    setPastedImages(prev => prev.filter(img => img.id !== imageId));
  };
  
  // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
  const handleFileButtonClick = () => {
    fileInputRef.current?.click();
  };
  
  // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠæ™‚ã®å‡¦ç†
  const handleFileChange = (e) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      if (file.type.startsWith('image/')) {
        const imageUrl = URL.createObjectURL(file);
        
        // ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¿½åŠ 
        setPastedImages(prev => [...prev, {
          id: Date.now().toString() + i,
          file: file,
          url: imageUrl
        }]);
      }
    }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆ
    e.target.value = '';
    
    toast.success('ç”»åƒãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸ');
  };
  
  // ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ã®åˆæœŸåŒ–ã¨çŠ¶æ…‹ç®¡ç†
  useEffect(() => {
    console.log('TaskComments component mounted for task:', taskId);
    
    // ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒåˆ©ç”¨å¯èƒ½ãªã‚‰é©åˆ‡ã«åˆæœŸåŒ–
    if (!useSimpleTextArea && quillRef.current) {
      try {
        const quill = quillRef.current.getEditor();
        
        // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰ã®ç”»åƒãƒšãƒ¼ã‚¹ãƒˆã‚’ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        const quillContainer = quill.root;
        quillContainer.addEventListener('paste', handlePaste);
        
        // ã‚¨ãƒ‡ã‚£ã‚¿ã®å†…éƒ¨çŠ¶æ…‹å¤‰æ›´ã‚’æ¤œçŸ¥ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        const textChangeHandler = (delta, oldDelta, source) => {
          if (source === 'user') {
            // @ãƒãƒ¼ã‚¯ã®æ¤œçŸ¥å‡¦ç†
            const text = quill.getText();
            const selection = quill.getSelection();
            const position = selection?.index || text.length;
            
            // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚ˆã‚Šå‰ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
            const textBeforeCursor = text.slice(0, position);
            
            // @ãƒãƒ¼ã‚¯ã®æ¤œç´¢ã¨å‡¦ç†
            const lastAtPos = textBeforeCursor.lastIndexOf('@');
            if (lastAtPos !== -1) {
              // @ãƒãƒ¼ã‚¯ã®å¾Œã«ç¶šãæ–‡å­—ãŒãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã‚¯ã‚¨ãƒª
              const query = textBeforeCursor.slice(lastAtPos + 1);
              
              // ã‚¹ãƒšãƒ¼ã‚¹ãŒãªã„ã‹ã€æœ€å¾Œã®@ã®å¾Œã«ä»–ã®@ãŒãªã„ã“ã¨ã‚’ç¢ºèª
              const noSpaceAfterAt = !query.includes(' ');
              const isValidQuery = noSpaceAfterAt && query.length > 0;
              
              if (isValidQuery || query === '') {
                // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã®è¡¨ç¤ºåº§æ¨™ã‚’å–å¾—
                if (selection) {
                  // @ãƒãƒ¼ã‚¯ã®ä½ç½®ã®DOMãƒãƒ¼ãƒ‰ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å–å¾—
                  const atSignPos = quill.getBounds(lastAtPos);
                  
                  // å€™è£œè¡¨ç¤ºä½ç½®ã‚’è¨­å®š
                  setMentionPosition({ 
                    x: atSignPos.left, 
                    y: atSignPos.bottom 
                  });
                }
                
                if (isValidQuery) {
                  console.log('Detected mention query:', query);
                  setMentionQuery(query);
                  setMentionQueryStart(lastAtPos);
                  setShowMentionSuggestions(true);
                } else if (query === '') {
                  // @ã ã‘ãŒå…¥åŠ›ã•ã‚ŒãŸå ´åˆã‚‚å€™è£œã‚’è¡¨ç¤º
                  console.log('Empty mention query, showing all users');
                  setMentionQuery('');
                  setMentionQueryStart(lastAtPos);
                  setShowMentionSuggestions(true);
                }
              }
            } else {
              // @ãƒãƒ¼ã‚¯ãŒãªã„å ´åˆã¯ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å€™è£œã‚’éè¡¨ç¤º
              if (showMentionSuggestions) {
                setShowMentionSuggestions(false);
              }
            }
          }
        };
        
        quill.on('text-change', textChangeHandler);
        
        return () => {
          // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°
          try {
            quillContainer.removeEventListener('paste', handlePaste);
            quill.off('text-change', textChangeHandler);
          } catch (err) {
            console.warn('Error during cleanup:', err);
          }
        };
      } catch (error) {
        console.error('Error initializing Quill editor:', error);
      }
    }
  }, [taskId, handlePaste, useSimpleTextArea, showMentionSuggestions]);

  // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®å¤‰æ›´ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleEditorChange = (content, delta, source, editor) => {
    setEditorHtml(content);
    if (editor) {
      // ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã‚‚ä¿æŒï¼ˆAPIé€ä¿¡ç”¨ï¼‰
      const plainText = editor.getText().trim();
      setNewComment(plainText);
      setEditorContent(plainText);
    }
  };

  // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å€™è£œé¸æŠæ™‚ã®ãƒãƒ³ãƒ‰ãƒ©
  const handleSelectMention = (user) => {
    try {
      const userName = user.get_full_name || user.email || user.username;
      
      // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’è¿½è·¡
      setMentionedUsers(prev => {
        // é‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ã«æ—¢å­˜ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
        const exists = prev.some(u => u.id === user.id);
        if (!exists) {
          console.log(`Adding user ${userName} to mentioned users list`);
          return [...prev, user];
        }
        return prev;
      });
      
      if (useSimpleTextArea) {
        // ã‚·ãƒ³ãƒ—ãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã®å ´åˆ
        const beforeMention = newComment.substring(0, mentionQueryStart);
        const afterMention = newComment.substring(mentionQueryStart + mentionQuery.length + 1);
        const updatedComment = `${beforeMention}@${userName} ${afterMention}`;
        
        setNewComment(updatedComment);
      } else {
        // Quillã‚¨ãƒ‡ã‚£ã‚¿ã®å ´åˆ
        if (quillRef.current) {
          const quill = quillRef.current.getEditor();
          const currentPosition = quill.getSelection()?.index || quill.getText().length;
          
          // @ãƒãƒ¼ã‚¯ã®ä½ç½®ã‹ã‚‰ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã¾ã§ã‚’å‰Šé™¤
          quill.deleteText(mentionQueryStart, (currentPosition - mentionQueryStart));
          
          // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã‚’æŒ¿å…¥ï¼ˆã‚¹ã‚¿ã‚¤ãƒ«ä»˜ãï¼‰
          quill.insertText(mentionQueryStart, `@${userName} `, {
            'color': '#2563eb',
            'bold': true
          });
          
          // ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç§»å‹•
          quill.setSelection(mentionQueryStart + userName.length + 2); // @, ãƒ¦ãƒ¼ã‚¶ãƒ¼å, ã‚¹ãƒšãƒ¼ã‚¹ã®å¾Œ
        }
      }
      
      // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      setShowMentionSuggestions(false);
      setMentionQueryStart(-1);
      setMentionQuery('');
      
    } catch (error) {
      console.error('ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³é¸æŠå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
      toast.error('ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    }
  };

  // ç‰¹æ®Šã‚­ãƒ¼å‡¦ç†
  const handleKeyDown = (e) => {
    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å€™è£œãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆ
    if (showMentionSuggestions) {
      // ä¸Šä¸‹ã‚­ãƒ¼ã«ã‚ˆã‚‹é¸æŠ
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        // é¸æŠå‡¦ç†ã‚’å®Ÿè£…ï¼ˆè¤‡é›‘ãªãŸã‚ä»Šå›ã¯çœç•¥ï¼‰
      }
      
      // Enterã‚­ãƒ¼ã«ã‚ˆã‚‹é¸æŠæ±ºå®š
      else if (e.key === 'Enter' && mentionSuggestions.length > 0) {
        e.preventDefault();
        handleSelectMention(mentionSuggestions[0]);
      }
      
      // Escã‚­ãƒ¼ã«ã‚ˆã‚‹ã‚­ãƒ£ãƒ³ã‚»ãƒ«
      else if (e.key === 'Escape') {
        e.preventDefault();
        setShowMentionSuggestions(false);
      }
    }
  };

  // ã‚³ãƒ¡ãƒ³ãƒˆé€ä¿¡
  const handleSubmit = async (e) => {
    e.preventDefault();
    // ã‚³ãƒ¡ãƒ³ãƒˆå†…å®¹ã¨ãƒ•ã‚¡ã‚¤ãƒ«æ·»ä»˜ã®ã©ã¡ã‚‰ã‹ãŒã‚ã‚Œã°é€ä¿¡å¯èƒ½
    if ((!newComment.trim() && !editorHtml) && pastedImages.length === 0) {
      toast.error('ã‚³ãƒ¡ãƒ³ãƒˆå†…å®¹ã¾ãŸã¯ç”»åƒã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      return;
    }
    
    setSubmitting(true);
    let addedComment;
    let savedComment = newComment; // ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    // ã‚·ãƒ³ãƒ—ãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ä½¿ç”¨æ™‚ã¯HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆ
    let savedHtml = useSimpleTextArea 
      ? `<p>${newComment.replace(/\n/g, '</p><p>')}</p>` 
      : editorHtml; // HTMLå½¢å¼
    
    // ç©ºã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆQuillãŒ<p><br></p>ã®ã‚ˆã†ãªç©ºè¦ç´ ã‚’ç”Ÿæˆã™ã‚‹å ´åˆãŒã‚ã‚‹ï¼‰
    if (!savedHtml || savedHtml === '<p><br></p>' || savedHtml === '<p></p>') {
      console.log('Empty HTML content detected, generating from plain text');
      savedHtml = `<p>${newComment.replace(/\n/g, '</p><p>')}</p>`;
    }
    
    console.log('é€ä¿¡ã™ã‚‹HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„:', savedHtml);
    console.log('é€ä¿¡ã™ã‚‹ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ:', savedComment);
    let imagePreviewUrls = pastedImages.map(img => img.url);
    
    // WebSocketæ¥ç¶šã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯ã‚’ç„¡åŠ¹åŒ–
    if (!wsEnabled) {
      setConnectionError(false);
    }
    
    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®IDãƒªã‚¹ãƒˆã‚’æº–å‚™
    const mentionedUserIds = mentionedUsers.map(user => user.id);
    const mentionedUserNames = mentionedUsers.map(user => user.get_full_name || user.email || user.username);
    
    console.log('ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼:', mentionedUserNames);
    
    // æ¥½è¦³çš„UIæ›´æ–° - é€ä¿¡ä¸­ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¡¨ç¤º
    const tempComment = {
      id: `temp-${Date.now()}`,
      content: savedComment,
      html_content: savedHtml, // HTMLå½¢å¼ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ä¿å­˜
      user_name: 'ã‚ãªãŸ', // ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼åã¯å¾Œã§APIã‹ã‚‰å–å¾—
      created_at: new Date().toISOString(),
      isSending: true,
      imageUrls: imagePreviewUrls,
      mentioned_user_ids: mentionedUserIds,
      mentioned_user_names: mentionedUserNames
    };
    
    console.log('ä¸€æ™‚çš„ãªã‚³ãƒ¡ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ:', {
      id: tempComment.id,
      has_html: !!tempComment.html_content,
      html_preview: tempComment.html_content?.substring(0, 50) + '...',
      content_preview: tempComment.content?.substring(0, 50) + '...',
      mentioned_users: tempComment.mentioned_user_names
    });
    
    // ä¸€æ™‚çš„ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¡¨ç¤ºï¼ˆãƒªã‚¹ãƒˆã®æœ€å¾Œã«è¿½åŠ ï¼‰
    setComments(prevComments => [...prevComments, tempComment]);
    
    try {
      console.log(`Sending comment to task ${taskId}`);
      
      // FormDataã‚’ä½œæˆã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã¨ä¸€ç·’ã«é€ä¿¡
      const formData = new FormData();
      formData.append('task', taskId);
      formData.append('content', savedComment);
      
      // å¿…ãšHTMLå½¢å¼ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚‚é€ä¿¡
      if (savedHtml && savedHtml.trim() !== '') {
        formData.append('html_content', savedHtml);
        console.log('Added HTML content to form data');
      } else {
        const generatedHtml = `<p>${savedComment.replace(/\n/g, '</p><p>')}</p>`;
        formData.append('html_content', generatedHtml);
        console.log('Generated and added HTML content from plain text');
      }
      
      // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æƒ…å ±ã‚’è¿½åŠ 
      if (mentionedUserIds.length > 0) {
        mentionedUserIds.forEach(userId => {
          formData.append('mentioned_users', userId);
        });
        console.log(`Added ${mentionedUserIds.length} mentioned users to form data`);
      }
      
      // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ 
      if (pastedImages.length > 0) {
        console.log(`Attaching ${pastedImages.length} images to comment`);
        pastedImages.forEach(img => {
          formData.append('files', img.file);
        });
      }
      
      // APIã§ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ ï¼ˆFormDataã‚’ä½¿ç”¨ï¼‰
      addedComment = await tasksApi.addCommentWithFiles(taskId, formData);
      console.log('Comment added successfully:', addedComment);
      toast.success('ã‚³ãƒ¡ãƒ³ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸ');
      
      // é€ä¿¡æˆåŠŸå¾Œã®å‡¦ç†
      // ã‚¨ãƒ‡ã‚£ã‚¿çŠ¶æ…‹ã‚’å®‰å…¨ã«ãƒªã‚»ãƒƒãƒˆ
      const resetEditor = () => {
        console.log('Resetting editor state after successful comment submission');
        
        if (!useSimpleTextArea && quillRef.current) {
          try {
            // ã‚¨ãƒ‡ã‚£ã‚¿å‚ç…§ãŒæœ‰åŠ¹ãªå ´åˆã®ã¿ãƒªã‚»ãƒƒãƒˆ
            const editor = quillRef.current.getEditor();
            
            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç©ºã«è¨­å®š
            editor.setContents([]);
            
            // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’æˆ»ã™
            setTimeout(() => {
              try {
                editor.focus();
              } catch (e) {
                console.warn('Failed to focus editor after reset:', e);
              }
            }, 50);
          } catch (err) {
            console.warn('Error resetting Quill editor:', err);
          }
        }
        
        // ReactçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        setNewComment('');
        setEditorHtml('');
        setEditorContent('');
        setMentionedUsers([]); // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒªã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
      };
      
      // çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆã‚’å®Ÿè¡Œ
      resetEditor();
      
      // æ·»ä»˜ç”»åƒã‚’ã‚¯ãƒªã‚¢
      setPastedImages([]);
      
      // ä¸€è¦§ã‚’å†å–å¾—ï¼ˆä¸€æ™‚ã‚³ãƒ¡ãƒ³ãƒˆã‚’å®Ÿéš›ã®ã‚³ãƒ¡ãƒ³ãƒˆã§ç½®ãæ›ãˆï¼‰
      await fetchComments();
      
      // APIå¿œç­”ã«ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ã‚Œã°é€šçŸ¥ã‚’è¡¨ç¤º
      if (addedComment && addedComment.mentioned_user_names && addedComment.mentioned_user_names.length > 0) {
        console.log('Comment includes mentions:', addedComment.mentioned_user_names);
        toast.success(`${addedComment.mentioned_user_names.length}äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã—ã¾ã—ãŸ`, {
          duration: 3000,
          icon: 'ğŸ‘¥',
        });
      }
      
    } catch (error) {
      console.error('Error adding comment:', error);
      toast.error('ã‚³ãƒ¡ãƒ³ãƒˆã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
      
      // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã€ä¸€æ™‚ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤
      setComments(prevComments => prevComments.filter(comment => comment.id !== tempComment.id));
      
      // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯å…¥åŠ›å†…å®¹ã‚’å¾©å…ƒ
      setNewComment(savedComment);
      setEditorHtml(savedHtml);
    } finally {
      setSubmitting(false);
    }
    
    // WebSocketãŒæœ‰åŠ¹ãªå ´åˆã®ã¿ã€ã‚¿ã‚¹ã‚¯å›ºæœ‰ã®WebSocketã«ã‚³ãƒ¡ãƒ³ãƒˆé€šçŸ¥ã‚’é€ä¿¡
    // ä»¥ä¸‹ã¯ãã®ã¾ã¾ä¿æŒï¼ˆå°†æ¥ã®å®Ÿè£…ã®ãŸã‚ï¼‰
    if (wsEnabled) {
      try {
        if (isConnected) {
          const wsSuccess = sendMessage(JSON.stringify({
            type: 'comment',
            data: {
              task_id: taskId,
              task_title: task?.title || 'ã‚¿ã‚¹ã‚¯',
              comment_id: addedComment.id,
              user_name: addedComment.user_name,
              content: savedComment,
              html_content: savedHtml, // HTMLå½¢å¼ã‚‚é€ä¿¡
              created_at: new Date().toISOString(),
              has_attachments: pastedImages.length > 0
            }
          }));
          
          if (wsSuccess) {
            console.log('Task comment WebSocket notification sent successfully');
          } else {
            console.warn('Failed to send WebSocket notification, but comment was saved to API');
            // è‡ªå‹•çš„ã«å†æ¥ç¶šã‚’è©¦ã¿ã‚‹
            if (connectionAttempts < 2) {
              setConnectionAttempts(prev => prev + 1);
              setTimeout(() => {
                console.log('Attempting to reconnect WebSocket after send failure...');
                connect();
              }, 1000);
            }
          }
        } else {
          console.warn('WebSocket not connected, cannot send notification');
          setConnectionError(true);
        }
      } catch (wsError) {
        console.error('Error sending WebSocket notification:', wsError);
        // WebSocketã‚¨ãƒ©ãƒ¼ã¯APIã®ã‚³ãƒ¡ãƒ³ãƒˆä¿å­˜ã«ã¯å½±éŸ¿ã—ãªã„
      }
    } else {
      console.log('WebSocket disabled, skipping notification');
    }
    
    // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ãŒã‚ã‚Œã°å®Ÿè¡Œ
    if (onCommentAdded && typeof onCommentAdded === 'function') {
      onCommentAdded();
    }
  };

  // ã‚³ãƒ¡ãƒ³ãƒˆå‰Šé™¤
  const handleDeleteComment = async (commentId) => {
    if (!window.confirm('ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) {
      return;
    }

    try {
      await tasksApi.deleteComment(commentId);
      toast.success('ã‚³ãƒ¡ãƒ³ãƒˆãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ');
      fetchComments();
    } catch (error) {
      console.error('Error deleting comment:', error);
      toast.error('ã‚³ãƒ¡ãƒ³ãƒˆã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  };

  // æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
  const formatDate = (dateString) => {
    if (!dateString) return '';
    try {
      const date = new Date(dateString);
      return `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥ ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
    } catch (error) {
      return dateString;
    }
  };

  // ã‚³ãƒ¡ãƒ³ãƒˆå†…ã®æ›¸å¼ã¨ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  const formatContent = (content) => {
    if (!content) return '';
    
    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã¨ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¨˜æ³•ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®šç¾©
    const patterns = [
      // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³
      { 
        regex: /@(\w+(?:\s+\w+)*)/g, 
        render: (match) => (
          <span className="text-blue-600 font-medium">
            {match[0]}
          </span>
        )
      },
      // å¤ªå­— (**text**)
      { 
        regex: /\*\*(.+?)\*\*/g, 
        render: (match) => (
          <span className="font-bold">
            {match[1]}
          </span>
        )
      },
      // æ–œä½“ (*text*)
      { 
        regex: /\*(.+?)\*/g, 
        render: (match) => (
          <span className="italic">
            {match[1]}
          </span>
        )
      },
      // ã‚³ãƒ¼ãƒ‰ (`text`)
      { 
        regex: /`(.+?)`/g, 
        render: (match) => (
          <code className="px-1 py-0.5 bg-gray-100 rounded font-mono text-sm">
            {match[1]}
          </code>
        )
      }
    ];
    
    // ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ†å‰²ã—ã¦å„ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åˆè‡´ã™ã‚‹éƒ¨åˆ†ã‚’ã‚¹ã‚¿ã‚¤ãƒ«é©ç”¨
    let segments = [{ text: content, isFormatted: false }];
    
    // å„ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã¤ã„ã¦é †ç•ªã«å‡¦ç†
    patterns.forEach(pattern => {
      const newSegments = [];
      
      segments.forEach(segment => {
        // æ—¢ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¯ãã®ã¾ã¾
        if (segment.isFormatted) {
          newSegments.push(segment);
          return;
        }
        
        // ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å‡¦ç†
        const text = segment.text;
        let lastIndex = 0;
        let match;
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ä¸€è‡´ã™ã‚‹ç®‡æ‰€ã‚’ã™ã¹ã¦è¦‹ã¤ã‘ã‚‹
        pattern.regex.lastIndex = 0; // ãƒªã‚»ãƒƒãƒˆ
        while ((match = pattern.regex.exec(text)) !== null) {
          // ãƒãƒƒãƒå‰ã®ãƒ†ã‚­ã‚¹ãƒˆ
          if (match.index > lastIndex) {
            newSegments.push({
              text: text.substring(lastIndex, match.index),
              isFormatted: false
            });
          }
          
          // ãƒãƒƒãƒã—ãŸãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•°ã§å‡¦ç†
          newSegments.push({
            element: pattern.render(match),
            isFormatted: true
          });
          
          lastIndex = match.index + match[0].length;
        }
        
        // æ®‹ã‚Šã®ãƒ†ã‚­ã‚¹ãƒˆ
        if (lastIndex < text.length) {
          newSegments.push({
            text: text.substring(lastIndex),
            isFormatted: false
          });
        }
      });
      
      segments = newSegments;
    });
    
    // æœ€çµ‚çš„ãªè¦ç´ ã®é…åˆ—ã‚’ä½œæˆ
    return segments.map((segment, index) => {
      if (segment.isFormatted) {
        return <React.Fragment key={index}>{segment.element}</React.Fragment>;
      } else {
        return <React.Fragment key={index}>{segment.text}</React.Fragment>;
      }
    });
  };

  // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å€™è£œã®UIä½ç½®ç®¡ç†
  const [mentionPosition, setMentionPosition] = useState({ x: 0, y: 0 });
  
  // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ä½ç½®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
  useEffect(() => {
    const handleMentionPosition = (e) => {
      const { x, y, query } = e.detail;
      console.log('Mention position updated:', x, y);
      setMentionPosition({ x, y });
    };
    
    document.addEventListener('mention-position', handleMentionPosition);
    
    return () => {
      document.removeEventListener('mention-position', handleMentionPosition);
    };
  }, []);

  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
  if (loading && comments.length === 0) {
    return (
      <div className="flex justify-center py-8">
        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary-600"></div>
      </div>
    );
  }

  // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
  if (error && comments.length === 0) {
    return (
      <div className="bg-red-50 text-red-600 p-4 rounded-lg">
        {error}
      </div>
    );
  }

  return (
    <div>
      {/* Quillã‚¨ãƒ‡ã‚£ã‚¿ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */}
      <style>{quillStyles}</style>
      {/* WebSocketæ¥ç¶šçŠ¶æ…‹è¡¨ç¤ºã¯éè¡¨ç¤ºï¼ˆé–‹ç™ºä¸­ï¼‰ */}
      {false && connectionError && (
        <div className="mb-4 bg-red-50 border border-red-200 rounded-md p-3 text-sm">
          <div className="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-red-500 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <span className="font-medium text-red-800">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ã¯ç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“</span>
            <button 
              onClick={handleReconnect} 
              className="ml-auto bg-red-600 text-white px-3 py-1 rounded-md text-xs hover:bg-red-700 transition-colors"
            >
              å†æ¥ç¶š
            </button>
          </div>
        </div>
      )}
      
      {/* æ¥ç¶šæˆåŠŸæ™‚ã®è¡¨ç¤ºï¼ˆç¾åœ¨ã¯éè¡¨ç¤ºï¼‰ */}
      {false && isConnected && !connectionError && (
        <div className="mb-4 bg-green-50 border border-green-200 rounded-md p-2 text-sm hidden md:block">
          <div className="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-green-500 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
            </svg>
            <span className="text-green-800 text-xs">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™</span>
          </div>
        </div>
      )}

      {/* ã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ */}
      <div className="mb-6 space-y-6">
        {loading && comments.length === 0 ? (
          <div className="flex justify-center py-4">
            <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-primary-600"></div>
          </div>
        ) : error && comments.length === 0 ? (
          <div className="bg-red-50 text-red-600 p-4 rounded-lg text-sm">
            {error}
            <button 
              onClick={fetchComments} 
              className="ml-2 underline hover:text-red-800"
            >
              å†è©¦è¡Œ
            </button>
          </div>
        ) : comments.length === 0 ? (
          <div className="text-center text-gray-500 py-4">
            ã‚³ãƒ¡ãƒ³ãƒˆã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“ã€‚æœ€åˆã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿ã—ã¾ã—ã‚‡ã†ã€‚
          </div>
        ) : (
          [...comments].sort((a, b) => new Date(a.created_at) - new Date(b.created_at)).map(comment => (
            <div 
              key={comment.id} 
              className={`bg-gray-50 rounded-lg p-4 ${comment.isSending ? 'opacity-70' : ''}`}
            >
              <div className="flex justify-between items-start">
                <div className="flex items-center">
                  <div className="w-8 h-8 bg-primary-500 text-white rounded-full flex items-center justify-center font-bold">
                    {comment.user_name?.[0] || 'U'}
                  </div>
                  <div className="ml-3">
                    <div className="flex items-center">
                      <p className="text-sm font-medium text-gray-900">
                        {comment.user_name || 'ãƒ¦ãƒ¼ã‚¶ãƒ¼'}
                      </p>
                      {comment.isSending && (
                        <span className="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">
                          é€ä¿¡ä¸­...
                        </span>
                      )}
                    </div>
                    <p className="text-xs text-gray-500">
                      {formatDate(comment.created_at)}
                    </p>
                  </div>
                </div>
                {!comment.isSending && (
                  <button
                    className="text-gray-400 hover:text-red-500"
                    onClick={() => handleDeleteComment(comment.id)}
                  >
                    <HiOutlineTrash className="w-4 h-4" />
                  </button>
                )}
              </div>
              {/* ã‚³ãƒ¡ãƒ³ãƒˆå†…å®¹è¡¨ç¤º */}
              {comment.html_content && comment.html_content !== '<p><br></p>' && comment.html_content !== '<p></p>' ? (
                // HTMLå½¢å¼ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’è¡¨ç¤º
                <div 
                  className="mt-3 text-sm text-gray-700 quill-content prose prose-sm max-w-none"
                  dangerouslySetInnerHTML={{ __html: comment.html_content }}
                />
              ) : (
                // ãã†ã§ãªã‘ã‚Œã°é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
                <div className="mt-3 text-sm text-gray-700 whitespace-pre-wrap">
                  {formatContent(comment.content)}
                </div>
              )}
              
              {/* ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³æƒ…å ±ï¼ˆã‚ã‚Œã°è¡¨ç¤ºï¼‰ */}
              {comment.mentioned_user_names && comment.mentioned_user_names.length > 0 && (
                <div className="mt-2 flex flex-wrap gap-1">
                  {comment.mentioned_user_names.map((name, index) => (
                    <span 
                      key={index} 
                      className="px-2 py-0.5 bg-blue-100 text-blue-800 text-xs rounded-full"
                    >
                      @{name}
                    </span>
                  ))}
                </div>
              )}
              
              {/* ç”»åƒæ·»ä»˜ãŒã‚ã‚‹å ´åˆ */}
              {(comment.attachments && comment.attachments.length > 0) && (
                <div className="mt-3 flex flex-wrap gap-2">
                  {comment.attachments.map((attachment, index) => (
                    <a 
                      key={index}
                      href={attachment.file} 
                      target="_blank"
                      rel="noopener noreferrer"
                      className="block relative"
                    >
                      <img 
                        src={attachment.file} 
                        alt={`æ·»ä»˜${index + 1}`}
                        className="max-w-xs max-h-40 rounded-md shadow-sm border border-gray-200"
                      />
                    </a>
                  ))}
                </div>
              )}
              
              {/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã®æ·»ä»˜ç”»åƒ */}
              {comment.imageUrls && comment.imageUrls.length > 0 && (
                <div className="mt-3 flex flex-wrap gap-2">
                  {comment.imageUrls.map((url, index) => (
                    <div key={index} className="relative">
                      <img 
                        src={url} 
                        alt={`æ·»ä»˜${index + 1}`}
                        className="max-w-xs max-h-40 rounded-md shadow-sm border border-gray-200 opacity-70"
                      />
                      <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-30 rounded-md">
                        <span className="text-white font-medium">
                          é€ä¿¡ä¸­...
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          ))
        )}
      </div>

      {/* ã‚³ãƒ¡ãƒ³ãƒˆå…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ  */}
      <div className="bg-gray-50 rounded-lg p-4">
        {/* ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºã‚¨ãƒªã‚¢ */}
        {pastedImages.length > 0 && (
          <div className="mb-4 p-3 bg-white rounded-lg border border-gray-200">
            <h4 className="text-sm font-medium text-gray-700 mb-2">æ·»ä»˜ç”»åƒ</h4>
            <div className="flex flex-wrap gap-3">
              {pastedImages.map((image, index) => (
                <div key={index} className="relative group">
                  <img 
                    src={image.url} 
                    alt={`æ·»ä»˜${index + 1}`} 
                    className="w-24 h-24 object-cover rounded border border-gray-300"
                  />
                  <button
                    className="absolute top-1 right-1 bg-red-500 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity"
                    onClick={() => handleRemoveImage(image.id)}
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                    </svg>
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
        
        <form onSubmit={handleSubmit} className="relative">
          {/* ãƒ•ã‚¡ã‚¤ãƒ«æ·»ä»˜ã®éè¡¨ç¤ºå…¥åŠ› */}
          <input
            type="file"
            ref={fileInputRef}
            className="hidden"
            accept="image/*"
            multiple
            onChange={handleFileChange}
          />
          
          {/* ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ */}
          <div className="flex items-start space-x-3">
            <div className="relative flex-1">
              {useSimpleTextArea ? (
                <textarea
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-primary-500 focus:border-primary-500"
                  value={newComment}
                  onChange={(e) => setNewComment(e.target.value)}
                  placeholder="ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥åŠ›..."
                  rows={4}
                  disabled={submitting}
                  style={{ minHeight: '100px' }}
                />
              ) : (
                <div className="quill-container" style={{ minHeight: '150px' }}>
                  <ReactQuill
                    ref={quillRef}
                    value={editorHtml}
                    onChange={handleEditorChange}
                    modules={modules}
                    formats={formats}
                    placeholder="ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥åŠ›... @ã§ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã€ç”»åƒã¯ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—"
                    theme="snow"
                    className="quill-editor"
                    style={{ height: '150px' }}
                  />
                </div>
              )}
              
              {/* ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å€™è£œ - ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã§ä»£æ›¿ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ */}
              {showMentionSuggestions && (
                <div 
                  ref={mentionSuggestionsRef}
                  className="absolute z-10 mt-1 w-60 bg-white rounded-md shadow-lg border border-gray-200"
                  style={{
                    // ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ã®ã¨ãã¯ä½ç½®ã‚’è¨ˆç®—ã€ãã†ã§ãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®
                    left: !useSimpleTextArea ? mentionPosition.x : undefined,
                    top: !useSimpleTextArea ? mentionPosition.y + 5 : undefined, // å°‘ã—ä¸‹ã«ãšã‚‰ã™
                  }}
                >
                  <ul className="py-1 max-h-60 overflow-auto">
                    {mentionSuggestions.length > 0 ? (
                      mentionSuggestions.map(user => (
                        <li 
                          key={user.id}
                          className="px-3 py-2 hover:bg-gray-100 cursor-pointer flex items-center"
                          onClick={() => handleSelectMention(user)}
                        >
                          <div className="w-6 h-6 bg-primary-500 text-white rounded-full flex items-center justify-center font-bold text-xs mr-2">
                            {(user.get_full_name || user.email || '')[0]}
                          </div>
                          <span>{user.get_full_name || user.email}</span>
                        </li>
                      ))
                    ) : (
                      <li className="px-3 py-2 text-gray-500 text-sm">
                        è©²å½“ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ã¾ã›ã‚“
                      </li>
                    )}
                  </ul>
                </div>
              )}
            </div>
            
            <button
              type="submit"
              className={`inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 ${
                submitting ? 'opacity-75 cursor-not-allowed' : ''
              }`}
              disabled={submitting}
              style={{ marginTop: '15px' }} // ã‚¨ãƒ‡ã‚£ã‚¿ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã¨æƒãˆã‚‹
            >
              <HiOutlinePaperAirplane className="-ml-1 mr-2 h-5 w-5 transform rotate-90" />
              é€ä¿¡
            </button>
          </div>
          
          {/* ç·¨é›†ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */}
          <div className="mt-2 flex space-x-2">
            <button
              type="button"
              className="p-1.5 text-gray-500 hover:text-primary-600 hover:bg-gray-100 rounded"
              onClick={handleFileButtonClick}
              title="ç”»åƒã‚’æ·»ä»˜"
            >
              <HiOutlinePaperClip className="h-5 w-5" />
            </button>
            <button
              type="button"
              className="p-1.5 text-gray-500 hover:text-primary-600 hover:bg-gray-100 rounded"
              onClick={() => {
                const quill = quillRef.current?.getEditor();
                if (quill) {
                  const selection = quill.getSelection();
                  if (selection) {
                    // @ãƒãƒ¼ã‚¯ã‚’ç¾åœ¨ã®ä½ç½®ã«æŒ¿å…¥
                    quill.insertText(selection.index, '@');
                    quill.setSelection(selection.index + 1);
                  }
                }
              }}
              title="ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³"
            >
              <HiOutlineAtSymbol className="h-5 w-5" />
            </button>
          </div>
        </form>
        
        {/* ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆ */}
        <div className="mt-2 text-xs text-gray-500">
          <p>@ã§ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã€ç”»åƒã¯ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰ãƒšãƒ¼ã‚¹ãƒˆã€**å¤ªå­—**ã€*æ–œä½“*ã€`ã‚³ãƒ¼ãƒ‰`ãªã©ã®æ›¸å¼ãŒä½¿ãˆã¾ã™ã€‚</p>
        </div>
      </div>
    </div>
  );
};

export default TaskComments;